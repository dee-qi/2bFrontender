# 定义

使用RegExp对象，可以使用构造函数，不过更多时使用一种特殊的直接量语法来构造。

```js
var pattern1 = /s$/; //匹配所有以s结尾的字符
var pattern2 = new RegExp('s$');
```

### 字符直接量

* 数字和字母 => 他们自己
* \o NUL字符(\u0000)
* \t 制表符(\u0009)
* \n 换行符(\u000A)
* \v 垂直制表符(\u000B)
* \f 换页符(\u000C)
* \r 回车符(\u000D)
* \xnn 由十六进制数nn指定的拉丁字符，如\x0A等价于\n
* \uxxx 由十六进制数xxxx指定的Unicode字符，如\u0009 等价于\t
* \cX 控制字符^X，如\cJ等价于\n

### 字符类

* [...] 方括号内任意字符
* [^...] 不在方括号内的任意字符
* . 除换行符和Unicode终止符之外的任意字符
* \w 任何**ASCII**字符组成的单词，等价于[a-zA-Z0-9]
* \W 任何**非ASCII**字符组成的单词，等价于[^a-zA-Z0-9]
* \s 任何Unicode空白字符
* \S 任何非Unicode空白字符
* \d 任何ASCII数字，等价于[0-9]
* \D 任何除了ASCII数字之外的字符，等价于[^0-9]
* [\b] 退格直接量

### 重复

* {n,m} 匹配前一项至少出现n次，但不超过m次
* {n,} 匹配前一项至少n次
* {n} 匹配前一项n次
* ? 匹配前一项0次或者1次{0,1}
* + 匹配前一项1次或者多次{1,}
* * 匹配前一项0次或者多次{0,}

> **非贪婪的匹配**
> 前面说的匹配方式都是尽可能多的匹配，如用/a+/来匹配字符'aaa'会匹配全部三个a
>> 如果在重复标记后加个问好，如??、+?等，就可以进行“非贪婪匹配”，这种匹配方式会尽可能少匹配。如用/a+?/来匹配'aaa'，只会匹配一个a
>>> 值得一提的是，正则表达式的模式匹配总会寻找字符串中第一个可能匹配的位置，所以/a+b/和/a+?b/来匹配'aaab'所得到的结果是一样的。

### 选择、分组和引用

> 选择

字符"|"用于分割供选择的字符。如```/ab|cd|efg/```可以匹配ab或者cd或者efg，```/\d+|[a-z]{4}/```可以匹配一个以上的数字或者四个字母。

在进行尝试时是从左到右的，只要匹配到一个合适的，就会忽略|右边的模式

> 分组（又名圆括号的作用）

圆括号的作用：

* 把单独的项组合成子表达式，如/java(script)?/匹配java或者javascript

* 在完整的模式中定义子模式。当一个正则表达式成功和目标字符串匹配时，可以从目标串中抽出圆括号中的子模式相匹配的部分。如/[a-z]+\d+/匹配一堆字母加一堆数字，而我们只在乎那串数字，可以用/[a-z]+(\d+)/

* 在同一正则表达式中后面引用前面的子表达式，使用方法：“\\+数字”，如\1引用第一个圆括号所匹配的文本（非模式）

* (?:xxx)只组合，不记忆与该组合匹配的字符。即用\\+数字引用时会忽略这个括号

### 指定匹配位置（锚元素）

* ^ 匹配字符串的开头，多行中对应一行的开头
* $ 匹配字符串的结尾，多行中对应一行的结尾
* \b 一个单词的边界，即\w和\W之间的位置，或者位于\w和字符串开头、结尾之间的位置
* \B 非单词边界的位置
* (?=p) 零宽正向先行断言，要求接下来的字符与p匹配
* (?!p) 零宽负向先行断言，要求接下来的字符不与p匹配

后两个的实例：
```js
/[Jj]ava([Ss]cript)?(?=\:) //能匹配'JavaScript: The Definitive Guide'中的'JavaScript'，但不能匹配'Java Programming Language'中的'Java'，因为它后面没跟着冒号

/Java(?!Script)[a-zA-Z0-9]*/ //不能匹配Java后面跟Script的字符
```

### 修饰符

出现在第二个斜线之后，用以说明高级匹配模式的规则。

* i 说明匹配模式不区分大小写
* g 全局的，找出被检索字符串中所有可行的匹配
* m 多行匹配，注意^和$的变化

****

用于模式匹配的String方法

* search()
  
  该方法返回第一个与模式匹配的子串的起始位置，找不到返回-1
  ```js
  'JavaScript'.search(/script/i); //返回4
  ```

* replace()

  第一个参数是正则表达式，第二个参数是要替换成的字符。把匹配到的字符串替换成第二个参数，注意有g没g的区别

  特殊用法：在第二个参数中加入$+数字i，会替换为正则表达式中的第i组
  ```js
  //把英文引号替换为中文引号
  var quote = /"([^"]*)"/g;
  text.replace(quote, '“$1”');
  ```
* match()

* split()